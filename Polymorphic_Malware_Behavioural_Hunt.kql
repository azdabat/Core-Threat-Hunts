//  Polymorphic Loader Detection (With Hunter Directives)
// Author: Ala Dabat
// Purpose: Compact behavioural analytic for detecting polymorphic loaders that drop DLL/EXE/SYS into writable paths,
//          load them rapidly, establish fast outbound connections, or execute via LOLBins.
// Suitable for: Tier 1/2 alerting, baseline threat-hunting packs, and lightweight behavioural correlation.
// For full engineering pack see Advanced Threat Hunting section and companion Fileless rule: Tune accordingly
// Polymorphic Loader Detection (Fixed & Tuned)
// Author: Ala Dabat (Fixed)
// Fixes: 
//   1. Fixed "ProcessId" join error (Now joins LoaderProcessId == ProcessId).
//   2. Added time-bounding to joins to prevent timeouts.
//   3. Added "Safe Installer" filter to reduce FP noise from updates.

let lookback = 3d;

// Writable location profiles
let suspicious_folders = dynamic(["\\ProgramData\\", "\\Users\\", "\\Temp\\", "\\Windows\\Temp\\"]);

// High-risk loader processes
let lolbins = dynamic(["rundll32.exe","regsvr32.exe","mshta.exe","powershell.exe","wscript.exe","cscript.exe","cmd.exe"]);

// 1. File Drops (The Artifact)
let drops =
DeviceFileEvents
| where Timestamp >= ago(lookback)
| where FileName endswith ".dll" or FileName endswith ".exe" or FileName endswith ".sys"
| where FolderPath has_any (suspicious_folders)
| project DeviceId, DeviceName, 
          DropTime=Timestamp, 
          DroppedFile=FileName, 
          DroppedPath=FolderPath, 
          DroppingProcessName=InitiatingProcessFileName, 
          DroppingProcessId=InitiatingProcessId,
          DropperSigner=InitiatingProcessSignerInfo.SignerName; // Capture signer for filtering

// 2. Suspicious Image Loads (The Execution)
let loads =
DeviceImageLoadEvents
| where Timestamp >= ago(lookback)
| where FileName endswith ".dll" or FileName endswith ".sys"
| where SignatureStatus in ("Unsigned","Invalid","Unknown") // Critical filter
| project DeviceId, 
          LoadTime=Timestamp, 
          LoadedFile=FileName, 
          LoaderProcessName=InitiatingProcessFileName, 
          LoaderProcessId=InitiatingProcessId,
          LoaderSigner=InitiatingProcessSignerInfo.SignerName;

// 3. Network Connections (The C2)
let net =
DeviceNetworkEvents
| where Timestamp >= ago(lookback)
| where ActionType == "ConnectionSuccess"
| where RemoteIPType != "Loopback"
| project DeviceId, 
          ConnectionTime=Timestamp, 
          ProcessId=InitiatingProcessId, // This needs to match the Loader
          RemoteIP, 
          RemoteUrl, 
          RemotePort;

// 4. Join and Correlate
drops
// Join Loads (Must happen AFTER drop, within 1 hour)
| join kind=inner (loads) on DeviceId, $left.DroppedFile == $right.LoadedFile
    | where LoadTime between (DropTime .. (DropTime + 1h))

// Join Network (Must happen AFTER load, within 10 mins)
// FIX: Join LoaderProcessId to Network ProcessId
| join kind=leftouter (net) on DeviceId, $left.LoaderProcessId == $right.ProcessId
    | where ConnectionTime between (LoadTime .. (LoadTime + 10m))

// 5. False Positive Filter: "Safe Installers"
// If both processes are signed by trusted vendors, it's likely an update
| where not(DropperSigner has "Microsoft" and LoaderSigner has "Microsoft")
| where not(DropperSigner has "Google" and LoaderSigner has "Google")

// 6. Metrics & Scoring
| extend LoadDelay = datetime_diff('minute', LoadTime, DropTime)
| extend C2Delay   = datetime_diff('second', ConnectionTime, DropTime)

// Behaviour flags
| extend FastLoad = iif(LoadDelay <= 5, 1, 0)
| extend FastC2   = iif(isnotempty(
