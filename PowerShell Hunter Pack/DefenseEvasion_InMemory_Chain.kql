// ============================================================================
// HUNT: PS_L3_InMemory_GapPlugger (L3)
// Author: Ala Dabat
//
// PURPOSE (Reality-based)
//   Detect PowerShell acting as a *runtime loader* by fusing:
//     (1) Intent telemetry (ScriptBlock / AMSI-like content signals)
//     (2) Action telemetry (EDR behavioral API-call events)
//     (3) Correlation gates (intent <-> action within time window)
//     (4) Prevalence suppression (common enterprise scripts ≠ alerts)
//
// TARGET
//   < 10% FP *after* environment tuning (allowlists + prevalence thresholds)
//
// IR FRAMEWORK (Hunter workflow)
//   - Triage: validate user/host/parent context + presence of action telemetry
//   - Contain: isolate if CRITICAL + correlated action (or AMSI/ETW tamper)
//   - Scope: pivot on DeviceId, AccountName, InitiatingProcess, RemoteUrl
//   - Eradicate: remove persistence, hunt follow-on injection + C2
//   - Recover: monitor re-infection signals, close gaps (logging/coverage)
//
// MITRE (common)
//   T1562.001 Impair Defenses | T1620 Reflective Loading | T1055 Injection
// ============================================================================

let lookback = 24h;
let corrWindow = 30m;

// -------------------------------
// 0) Tunables (tenant-specific)
// -------------------------------

// High-signal “loader action” tokens (rare in benign scripts)
let HighSignalTokens = dynamic([
  "virtualalloc", "writeprocessmemory", "createremotethread", "createthread",
  "getdelegateforfunctionpointer", "marshal]::copy", "dllimport",
  "entrypoint.invoke", "unsafe", "ntallocatevirtualmemory", "ntprotectvirtualmemory"
]);

// High-signal “defense impairment” tokens
let DefImpairTokens = dynamic([
  "amsiutils", "amsiinitfailed", "amsiscanbuffer", "etweventwrite"
]);

// Stager tokens (need additional gates to avoid noise)
let StagerTokens = dynamic([
  "iex", "downloadstring", "invoke-webrequest", "iwr", "invoke-restmethod", "irm",
  "-enc", "-encodedcommand"
]);

// Common enterprise noise anchors (expand per tenant)
let NoiseAnchors = dynamic([
  "compattelrunner", "scom", "monitoringhost", "sccm", "autogenerated"
]);

// Known-good service accounts (expand per tenant)
let KnownGoodAccounts = dynamic([
  "svc_scom", "svc_sccm"
]);

// Known-good parents (expand per tenant)
let KnownGoodParents = dynamic([
  "monitoringhost.exe", "sccmexec.exe", "services.exe"
]);

// Suspicious “initial access” parents (context boost)
let SuspiciousParents = dynamic([
  "winword.exe","excel.exe","powerpnt.exe","outlook.exe",
  "wscript.exe","cscript.exe","mshta.exe","cmd.exe","rundll32.exe","regsvr32.exe"
]);

// -------------------------------
// 1) Script / AMSI Layer (INTENT)
// -------------------------------

let ScriptLayer =
DeviceEvents
| where Timestamp >= ago(lookback)
| where ActionType in ("PowerShellCommand","PowerShellScriptBlock","AmrScriptDetected")
| extend Raw = tostring(AdditionalFields)
| extend Cmd = tostring(Commandline)
| extend Url = tostring(RemoteUrl)
| extend Clean = tolower(strcat(Raw, " ", Cmd, " ", Url))

// Noise suppression (baseline)
| where not(Clean has_any (NoiseAnchors))

// Token presence
| extend HasDefImpair = Clean has_any (DefImpairTokens)
| extend HasHighSignal = Clean has_any (HighSignalTokens)
| extend HasStager = Clean has_any (StagerTokens)

// “Combo” rules: avoid firing on reflection/base64 alone
// - DefImpair is always high confidence
// - HighSignal is high confidence
// - Stager requires context (suspicious parent or RemoteUrl) to reduce noise
| extend SuspParent = tolower(tostring(InitiatingProcessFileName)) has_any (SuspiciousParents)
| extend StagerGated = HasStager and (SuspParent or isnotempty(Url) or Clean has "downloadstring")

| where HasDefImpair or HasHighSignal or StagerGated

// Fingerprint for prevalence suppression (hash of Clean text; adjust to substring if needed)
| extend ScriptFingerprint = hash_sha256(Clean)

| project
    ScriptTime = Timestamp,
    DeviceId,
    DeviceName,
    AccountName,
    InitiatingProcessFileName,
    ActionType,
    Clean,
    Url,
    HasDefImpair,
    HasHighSignal,
    StagerGated,
    ScriptFingerprint;

// -------------------------------
// 2) Behavioral API Layer (ACTION)
// -------------------------------

// NOTE: Exact ActionType names vary by telemetry source.
// Keep the “action family” broad but gate via correlation + allowlists.
let ApiLayer =
DeviceEvents
| where Timestamp >= ago(lookback)
| where ActionType in (
    "CreateRemoteThreadApiCall",
    "WriteProcessMemoryApiCall",
    "NtAllocateVirtualMemoryApiCall",
    "VirtualProtectApiCall"
  )
| where FileName in~ ("powershell.exe","pwsh.exe","powershell_ise.exe")
| project
    ApiTime = Timestamp,
    DeviceId,
    DeviceName,
    AccountName,
    ApiAction = ActionType,
    FileName,
    InitiatingProcessFileName;

// -------------------------------
// 3) Prevalence suppression (global “common script” gate)
// -------------------------------

let ScriptPrevalence =
ScriptLayer
| summarize ScriptDevicePrevalence = dcount(DeviceId) by ScriptFingerprint;

// Suppress widely prevalent scripts unless they’re defense-impair or have action tokens
let ScriptLayerTight =
ScriptLayer
| join kind=leftouter ScriptPrevalence on ScriptFingerprint
| where (HasDefImpair or HasHighSignal) or (ScriptDevicePrevalence <= 3);

// -------------------------------
// 4) Correlate INTENT <-> ACTION (L3 gate)
// -------------------------------

ScriptLayerTight
| join kind=leftouter (
    ApiLayer
) on DeviceId, AccountName
| where isnull(ApiTime) or (ApiTime between (ScriptTime - corrWindow .. ScriptTime + corrWindow))

// Tenant allowlists (apply late, after correlation)
| where not(AccountName has_any (KnownGoodAccounts))
| where not(tolower(tostring(InitiatingProcessFileName)) has_any (KnownGoodParents))

// -------------------------------
// 5) Severity + Risk Scoring
// -------------------------------

| extend CorrelatedApi = iff(isnotempty(tostring(ApiAction)), true, false)
| extend Criticality =
    case(
      HasDefImpair and CorrelatedApi, "CRITICAL",         // disable defenses + action observed
      HasDefImpair, "CRITICAL",                           // defense impairment alone is rare/urgent
      HasHighSignal and CorrelatedApi, "CRITICAL",         // loader tokens + action observed
      ApiAction in ("CreateRemoteThreadApiCall","WriteProcessMemoryApiCall"), "HIGH",
      HasHighSignal, "HIGH",
      StagerGated and CorrelatedApi, "HIGH",
      StagerGated, "MEDIUM",
      "MEDIUM"
    )
| extend RiskScore =
    case(
      Criticality == "CRITICAL", 100,
      Criticality == "HIGH", 85,
      60
    )

// -------------------------------
// 6) Hunter output + IR directives
// -------------------------------

| project
    Timestamp = coalesce(ApiTime, ScriptTime),
    DeviceName,
    DeviceId,
    AccountName,
    Criticality,
    RiskScore,
    DetectionIntent = strcat("DefImpair=", tostring(HasDefImpair), "; HighSignal=", tostring(HasHighSignal), "; StagerGated=", tostring(StagerGated)),
    CorrelatedApi,
    ApiAction,
    Parent = InitiatingProcessFileName,
    RemoteUrl = Url,
    Evidence = Clean
| extend
    HuntName = "PS_L3_InMemory_GapPlugger",
    HuntingDirectives = case(
      Criticality == "CRITICAL",
        strcat(
          "TRIAGE: Validate parent process + user context; check if ScriptBlock/AMSI logs show tamper/loader tokens. ",
          "CONTAIN: Isolate host if business-approved. ",
          "SCOPE: Pivot on DeviceId+AccountName over 7d; hunt child processes + injection targets; enumerate outbound connections post-event. ",
          "ERADICATE: Remove persistence, revoke tokens/creds if compromise suspected, collect memory artefacts if feasible. ",
          "RECOVER: Confirm logging coverage (ScriptBlock/AMSI) and harden PS constrained language / ASR where applicable."
        ),
      Criticality == "HIGH",
        "TRIAGE: Confirm if API-call correlation exists; inspect parent chain + any RemoteUrl; pivot for follow-on injection/C2.",
      "TRIAGE: Treat as suspicious stager; validate prevalence + admin script legitimacy; pivot for corroborating signals."
    )
| sort by Timestamp desc
