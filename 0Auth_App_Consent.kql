// Advanced Hunt: Risk-Based OAuth Consent Analysis (Scopes + Burst + Admin)
// Author: Ala Dabat
// Purpose: Detects illicit consent grants by analyzing permission severity and consent bursts (phishing patterns).

let Lookback = 24h;
// 1. Define High-Risk Keywords in Permissions (Scopes)
let RiskyScopes = dynamic(["Mail.Read", "Mail.ReadWrite", "Files.Read", "Files.Read.All", "Notes.Read.All", "User.ReadWrite.All", "Directory.ReadWrite.All"]);
// 2. Define Safe Publishers (Reduce Noise)
let SafePublishers = dynamic(["Microsoft Services", "Microsoft Corporation"]); 

// 3. Base Event: Successful Application Consents
let ConsentEvents = 
    AuditLogs
    | where TimeGenerated > ago(Lookback)
    | where OperationName == "Consent to application"
    | where Result == "success"
    | extend Target = TargetResources[0]
    | extend Initiator = tostring(InitiatedBy.user.userPrincipalName)
    | extend IPAddress = tostring(InitiatedBy.user.ipAddress)
    | extend UserAgent = tostring(InitiatedBy.user.userAgent)
    | extend AppDisplayName = tostring(Target.displayName)
    | extend AppId = tostring(Target.id)
    // 4. Extract Critical Context from ModifiedProperties
    | mv-apply Prop = Target.modifiedProperties on (
        summarize 
            IsAdminConsent = take_anyif(tostring(Prop.newValue), Prop.displayName == "ConsentContext.OnBehalfOfAll"),
            GrantedScopes  = take_anyif(tostring(Prop.newValue), Prop.displayName == "ConsentContext.Permissions"), // The actual permissions (e.g. "Mail.Read")
            Publisher      = take_anyif(tostring(Prop.newValue), Prop.displayName == "PublisherName") // Note: Field availability varies by tenant config
    )
    | extend IsAdminConsent = iff(IsAdminConsent =~ "True", 1, 0)
    | extend Publisher = iff(isempty(Publisher), "Unknown", Publisher);

// 5. Burst Analysis: How many unique users consented to this AppID in the window?
let AppPopularity = 
    ConsentEvents
    | summarize ConsentCount = dcount(Initiator) by AppId;

// 6. Enrichment & Scoring
ConsentEvents
| join kind=leftouter (AppPopularity) on AppId
| extend 
    // Score 1: Admin Consent (Critical Impact)
    Score_Admin = iff(IsAdminConsent == 1, 10, 0),
    // Score 2: Risky Scopes (Data Exfil Potential)
    Score_Scopes = iff(GrantedScopes has_any (RiskyScopes), 10, 0),
    // Score 3: Phishing Burst (Multiple users tricked into consenting)
    Score_Burst = iff(ConsentCount >= 3, 5, 0), 
    // Score 4: Unverified Publisher
    Score_Publisher = iff(Publisher !in (SafePublishers) and Publisher != "Unknown", 5, 0)

| extend RiskScore = Score_Admin + Score_Scopes + Score_Burst + Score_Publisher
// 7. Filter Noise (Only show interesting events)
| where RiskScore >= 5 

// 8. Dynamic Hunter Directive
| extend HunterDirective = case(
    RiskScore >= 20, strcat("CRITICAL: Illicit Consent Grant suspected. Admin-level permissions (", GrantedScopes, ") granted to '", AppDisplayName, "'. Burst activity detected (", ConsentCount, " users)."),
    RiskScore >= 10, strcat("HIGH: Risky App Permissions. '", AppDisplayName, "' granted sensitive scopes: ", GrantedScopes),
    "MEDIUM: Non-standard OAuth consent detected."
)

// 9. Final Projection for the Analyst
| project 
    TimeGenerated, 
    RiskScore, 
    HunterDirective, 
    AppDisplayName, 
    AppId, 
    Initiator, 
    IPAddress, 
    IsAdminConsent, 
    GrantedScopes, 
    ConsentCount, 
    Publisher
| sort by RiskScore desc, TimeGenerated desc

// ============================================================================
// Incident Response (Runbook) — OAuth Consent Abuse
// Add these steps at the end so the hunt output is immediately actionable.
// ============================================================================
// 1) Validate the consent event
//    - Confirm AppDisplayName/AppId, Initiator, IPAddress, UserAgent, and whether IsAdminConsent == 1.
//    - Check if the app is new to the tenant and whether Publisher is expected (or "Unknown").
//
// 2) Scope impact triage
//    - If GrantedScopes includes: Directory.ReadWrite.All / User.ReadWrite.All => treat as identity takeover risk.
//    - If GrantedScopes includes: Mail.ReadWrite / Files.Read.All => treat as data access/exfil risk.
//    - Map “what can be read/modified” to affected services (Exchange/SharePoint/OneDrive/Entra ID).
//
// 3) Containment (priority order)
//    - Immediately revoke the app’s access: disable the service principal / remove OAuth grants / revoke admin consent.
//    - Reset compromised user sessions and tokens (revoke refresh tokens) for Initiator and other consenting users.
//    - If admin consent occurred: audit privileged roles and review recent role assignments.
//    - Block suspicious source IPs (where appropriate) and enforce Conditional Access for risky sign-ins.
//
// 4) Hunt expansion / pivots (same AppId)
//    - Pivot: list all users who consented to the same AppId within 7–30 days.
//    - Pivot: review SigninLogs for the consenting users around TimeGenerated (impossible travel, unfamiliar locations/devices).
//    - Pivot: review AuditLogs for “Add service principal”, “Update application”, “Add app role assignment”, “Grant consent”.
//    - Pivot: check MailboxAudit / UnifiedAuditLog for abnormal mailbox access or mass download patterns post-consent.
//
// 5) Eradication & recovery
//    - Remove the malicious app registration if tenant-owned; otherwise remove enterprise application and permissions.
//    - Rotate secrets: impacted mailbox rules, OAuth tokens, and any credentials exposed via mail/file access.
//    - Check for persistence: new inbox rules, forwarding, OAuth app re-consent attempts, new CA bypasses.
//
// 6) Lessons learned / hardening
//    - Enforce admin consent workflow (require approval), restrict user consent, and limit allowed publishers.
//    - Alert on bursty consent patterns (ConsentCount spikes) and risky scopes granted by non-admins.
//    - Baseline “known-good” publishers/apps; maintain an allowlist for sanctioned integrations.
// ============================================================================
